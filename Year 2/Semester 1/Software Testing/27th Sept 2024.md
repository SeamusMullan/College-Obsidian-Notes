#testing #year2 

## Intro to Software Testing

### sw industry

GECKO
- Humis (spelling?)

removing specificity for software testing, went to microsoftl lol

software improvement term coined, still exists.
importance in QA and in engineering. Managing time and budgets.
Defines roles and helps planning and documentaiton

### TTD: Test Driven Development
Define things the code should do, without any prior context on how that could be developed but the expectations of the system should be able to handle errors that could occur when trying to reach the outcome.

in 1970s testing moved from after development to during development.

No single method of testing works for all code, but its constantly improving


reduced quality damages systems, reputations, can cost businesses money


### What is software testing

a process of finding assessing and predicting defects in software with the aim to reliably build large scale and high quality applications.
*See book S1.1.2 P4*

### Types of flaws and defects
- Mistakes -> developer
- faults -> in code
- failures -> incorrect (out of spec) behaviour
*see book s1.2; P4-5*

#### Types of faults

- algorithmic
- precision
- syntax
- documentations
- capacity / boundary

## Heuristics

- high probability of finding faults
- no dupes
- be independent
- test as much code as possible

### Black box
- examine without looking at implementation
### White box testing
- examine with access to internal structures, use perspective of system to create test cases
### Experience based
- erruro guessing / expert opinions
### Fault insertion
- intentionally entering faults

### When to finish testing?
Depends on time, money, plans, quality criteria, other variables

## Static / dynamic testing

**Static testing**
review based 
code revioew

proving mathematically

**Dynamic testing**
execute code and verify output

### Kinds of testing

unit -> test a part
integration, multiple units
regression, change while testing
sub system, well defined sections testing (ie packages)
system testing, entire system fault testing
acceptance testing, ask end user if output is expected

