#year3 #swdes 

## DbC (Design by Contract)
### Supplier and Client overview

**The Supplier** writes code, documents and maintains it. Knows the *implementation* and provides an interface.

**The Client** uses the interface provided, does *not* know about the implementation and uses documentation provided by the supplier to implement the functionality.

Without DbC the client may not understand:
- When a method can be used
- the consequences of running a method
- how interfaces change when the supplier updates the implementation

Following from this, if the interface *does* change, how does the supplier ensure consistency?

## Main principles of DbC

Every public method has a **pre** and **post** condition, both of which are boolean.

The precondition expresses constrains under which the method will function properly.
- Think of it like the requirements *before* the method runs.

The postcondition expresses what will happen when a method executes properly.
- Think of this like the outcomes / side-effects *after* a method runs.

***IF** the client runs the method in situations that satisfy the precondition **THEN** the supplier will make sure the method execution will always deliver a state that satisfies the postcondition.*

### Obligations and benefits.

see slides for tables, summary is that suppliers and clients have obligations to ensure the correct functionality of the code and the benefits are that the code.. runs....

### Non-Redundancy Principle

The body of a method shall not check to see if the precondition is true. This DBC principle is the opposite of *defensive programming* ie checking if an argument isnt null before computing.

DBC reduces overhead and complexity added by these checks

Ideally the client has already checked the precondition for another purpose (eg verifying a valid email in a sign up dialog) so.. *how many times do we **have** to check*

### Precondition Availability Rule

Every feature appearing in the precondition must be available to every client who can use the routine.

Basically they need to have access to the attributes or features of some routine or method they intend to use. This is reasonable since the client has to establish the precondition before calling the method (see above). A method / routine shouldn't refer to something the client doesn't have access too.

Think of it like MC modding, you need access to internal methods for Minecraft, but without docs, variables or interfaces you can't safely guarantee your interaction will reach a postcondition that is valid for your use case.

Checking this rule holds can be done by the compiler. The same is *not* true for the postcondition since it may refer to private attributes, eg if we return a private / internal implementation inside the method. It doesn't matter as long as it works.

### Violating an Assertion

If an assertion is not satisfied (pre/post conditions), what happens?

We can:
- throw an exception
- tell the user what assertion has been violated and how

**Note**:
- if a *precondition* is violated, its the users/clients problem.
- If a *postcondition* is violated, its the suppliers problem

**What assertions are *not***
- Software-to-Software contracts
- Software-to-User checks / Software-to-Device checks

Bad user input should be dealt with by writing the proper code.

Assertions shouldnt change the structure of the program. A properly working piece of code shouldnt throw assertions. You shouldn't try to catch an assertion and fix things, since you have done something wrong in your source code.

Assertions AND Exceptions are not coding structures.

### Example

If we have a `Stack` class which holds a sequence of `ELEMENT`s, see slides for UML / definition

How do we define the preconditions and postconditions?
Think about what's needed before a method runs.
Think about what should happen after it runs.

to run a method like `pop()` we require an item to exist in the stack as a precondition, and as a postcondition we would require the output of the item on the top of the stack. The size of the stack should also decrease.

### Class Invariants

Its just an assertion involving the class and instance variables.

all objects of the class must satisfy the invariate at all stable times ie before and after execution of public methods, after execution of constructors.

**Corollary 1**: Private methods can violate the invariant
**Corollary 2**: its the class suppliers job to make sure the constructors and public methods maintain the invariant.

